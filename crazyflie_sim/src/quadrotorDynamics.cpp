/*
 * quadrotorDynamics.cpp
 *
 *  Created On : 28/06/18
 *      Author : Jingyuan Hou
 *      Email  : jingyuan.hou@mail.utoronto.ca
 */

#include "crazyflie_sim/quadrotorDynamics.h"
#include "crazyflie_sim/utility.h"
#include <iostream>
#include <cmath>

// Static data memeber
Parameter QuadrotorDynamics::param;

/*
 * Compute thrust forces generated by each motor
 * Input: 4 by 1 vector of motor_rpm
 */
void QuadrotorDynamics::determine_force(const Eigen::Vector4d& motor_rpm){

    current_force = param.Ct * Eigen::Vector4d( motor_rpm.array().square() );

}

/*
 * Compute torque in body frame generated by motor thrust
 * Input: 4 by 1 vector of motor_rpm
 */
void QuadrotorDynamics::determine_torque(const Eigen::Vector4d& motor_rpm){

    current_torque = param.rpm_to_torque * Eigen::Vector4d( motor_rpm.array().square() );

}

/*
 * In place update the current drone state using drone dynamics
 * Input: current state object, 4 by 1 vector of motor_rpm and vector of pointer to external force function
 * Output: constant reference to updated current state object
 * external_force parameter is a vector of pointer to function that take the state as input and return forces on the quadrotor in global coordinates.
 */

// this version computes rate of change of R and updates R using rate of change of R
const State& QuadrotorDynamics::update_state(State& current_state, const Eigen::Vector4d& motor_rpm, const std::vector<ptr_func >& external_force) {

    // update rate of change of position and velocity of COM in world frame
    const Eigen::Vector3d& pos_rate = current_state.get_velocity();
    const Eigen::Vector3d& vel_rate = current_state.get_acceleration();

    // compute acceleration of COM in world frame
    determine_force(motor_rpm);                                                         // compute motor thrust forces in body frame
    Eigen::Vector3d acc = Eigen::Vector3d::Zero();
    for(auto iter = external_force.begin(); iter != external_force.end(); ++iter){      // add external forces(world frame)
        acc += (*iter)(current_state);
    }
    acc += current_force.sum() * current_state.get_R().col(2);                          // add thrust forces in world frame
    acc /= param.m;                                                                     // convert force to acceleration
    acc(2) -= param.g;                                                                  // add in gravity

    // compute rate of change of R
    Eigen::Matrix3d omega_cross = Eigen::Matrix3d::Identity();
    omega_cross <<                          0.0, -current_state.get_omega()(2),   current_state.get_omega()(1),     // skew symmetric matrix
                   current_state.get_omega()(2),                           0.0,  -current_state.get_omega()(0),
                  -current_state.get_omega()(1),  current_state.get_omega()(0),                            0.0;
    Eigen::Matrix3d R_rate = current_state.get_R() * omega_cross;

    // compute rate of change of angular velocity
    determine_torque(motor_rpm);    // compute torque about COM in body frame
    Eigen::Vector3d omega_rate = param.inertia_inv * ( current_torque - current_state.get_omega().cross(param.inertia * current_state.get_omega()) ); // compute rate of change of angular velocity
    //Eigen::Vector3d omega_rate = param.inertia_inv * (current_torque - omega_cross * param.inertia * current_state.get_omega());

    // integrate derivative terms to get updated current_state
    current_state.set_position( pos_rate * dt + current_state.get_position());          // update position
    current_state.set_velocity( vel_rate * dt + current_state.get_velocity());          // update velocity
    current_state.set_acceleration(acc);                                                // update acceleration

    current_state.set_R( R_rate * dt + current_state.get_R());      // set non orthogonal R
    current_state.set_euler( current_state.get_euler_from_R());     // update euler angle from latest raw R
    current_state.set_R( current_state.get_R_from_euler() );        // set orthogonal R from euler angels

    current_state.set_omega( omega_rate * dt + current_state.get_omega());              // update angular velocity

    // constrain drone's state when it is on the ground
    grounding(current_state, acc);

    // update updated_state member
    updated_state = current_state;

    //std::cout<< "omega: " <<current_state.get_omega()(0)<<" "<<current_state.get_omega()(1)<<" "<<current_state.get_omega()(2)<<std::endl;
    //std::cout<< "omega_rate: "<<omega_rate(0)<<" "<<omega_rate(1)<<" "<<omega_rate(2)<<std::endl;
    //std::cout<< "euler: "<<current_state.get_euler()(0)<<" "<<current_state.get_euler()(1)<<" "<<current_state.get_euler()(2)<<std::endl;
    //std::cout<< "motor_rpm: "<<motor_rpm(0)<<" "<<motor_rpm(1)<<" "<<motor_rpm(2)<<" "<<motor_rpm(3)<<std::endl;


    return current_state;
}

// this version computes rate of change of euler angle and then updates R through new euler angles
const State& QuadrotorDynamics::update_state2(State& current_state, const Eigen::Vector4d& motor_rpm, const std::vector<ptr_func >& external_force){

    // update rate of change of position and velocity of COM in world frame
    const Eigen::Vector3d& pos_rate = current_state.get_velocity();
    const Eigen::Vector3d& vel_rate = current_state.get_acceleration();

    // compute acceleration of COM in world frame
    determine_force(motor_rpm);                                                         // compute motor thrust forces in body frame
    Eigen::Vector3d acc = Eigen::Vector3d::Zero();
    for(auto iter = external_force.begin(); iter != external_force.end(); ++iter){      // add external forces(world frame)
        acc += (*iter)(current_state);
    }
    acc += current_force.sum() * current_state.get_R().col(2);                          // add thrust forces in world frame
    acc /= param.m;                                                                     // convert force to acceleration
    acc(2) -= param.g;                                                                  // add in gravity

    // compute rate of change of euler angles
    Eigen::Matrix3d mapping = Eigen::Matrix3d::Identity();    // matrix that map angular velocity to euler angle base on 3-2-1 convention
    mapping << 1.0,   std::sin(current_state.get_euler()(0)) * std::tan(current_state.get_euler()(1)),   std::cos(current_state.get_euler()(0)) * std::tan(current_state.get_euler()(1)),
               0.0,                                            std::cos(current_state.get_euler()(0)),                                           -std::sin(current_state.get_euler()(0)),
               0.0,   std::sin(current_state.get_euler()(0)) / std::cos(current_state.get_euler()(1)),   std::cos(current_state.get_euler()(0)) / std::cos(current_state.get_euler()(1));
    Eigen::Vector3d euler_rate = mapping * current_state.get_omega();

    // compute rate of change of angular velocity
    determine_torque(motor_rpm);    // compute torque about COM in body frame
    Eigen::Vector3d omega_rate = param.inertia_inv * ( current_torque - current_state.get_omega().cross(param.inertia * current_state.get_omega()) ); // compute rate of change of angular velocity

    // integrate derivative terms to get updated current_state
    current_state.set_position( pos_rate * dt + current_state.get_position());      // update position
    current_state.set_velocity( vel_rate * dt + current_state.get_velocity());      // update velocity
    current_state.set_acceleration(acc);                                            // update acceleration
    current_state.set_omega( omega_rate * dt + current_state.get_omega());          // update angular velocity
    current_state.set_euler( euler_rate * dt + current_state.get_euler());          // update euler angle
    current_state.set_R( current_state.get_R_from_euler() );                        // update rotation matrix

    // constrain drone's state when it is on the ground
    grounding(current_state, acc);

    // update updated_state member
    updated_state = current_state;

    //std::cout<< "omega: " <<current_state.get_omega()(0)<<" "<<current_state.get_omega()(1)<<" "<<current_state.get_omega()(2)<<std::endl;
    //std::cout<< "omega_rate: "<<omega_rate(0)<<" "<<omega_rate(1)<<" "<<omega_rate(2)<<std::endl;
    //std::cout<< "euler: "<<current_state.get_euler()(0)<<" "<<current_state.get_euler()(1)<<" "<<current_state.get_euler()(2)<<std::endl;

    return current_state;
}


// this version computes rate of change of quaternion and then updates R through new quaternion
const State& QuadrotorDynamics::update_state3(State& current_state, const Eigen::Vector4d& motor_rpm, const std::vector<ptr_func >& external_force){

    // update rate of change of position and velocity of COM in world frame
    const Eigen::Vector3d& pos_rate = current_state.get_velocity();
    const Eigen::Vector3d& vel_rate = current_state.get_acceleration();

    // compute acceleration of COM in world frame
    determine_force(motor_rpm);                                                         // compute motor thrust forces in body frame
    Eigen::Vector3d acc = Eigen::Vector3d::Zero();
    for(auto iter = external_force.begin(); iter != external_force.end(); ++iter){      // add external forces(world frame)
        acc += (*iter)(current_state);
    }
    acc += current_force.sum() * current_state.get_R().col(2);                          // add thrust forces in world frame
    acc /= param.m;                                                                     // convert force to acceleration
    acc(2) -= param.g;                                                                  // add in gravity

    // compute rate of change of angular velocity
    determine_torque(motor_rpm);    // compute torque about COM in body frame
    Eigen::Vector3d omega_rate = param.inertia_inv * ( current_torque - current_state.get_omega().cross(param.inertia * current_state.get_omega()) ); // compute rate of change of angular velocity

    // compute new quaternion
    Eigen::Vector3d vector = current_state.get_quaternion().vec();
    double scalar = current_state.get_quaternion().w();

    Eigen::Quaterniond quat;
    quat.w() = -0.5 * vector.dot(current_state.get_omega()) * dt + scalar;

    Eigen::Matrix3d vector_cross;
    vector_cross <<    scalar, -vector(2),  vector(1),
                    vector(2),     scalar, -vector(0),
                   -vector(1),  vector(0),     scalar;

    quat.vec() = 0.5 * vector_cross * current_state.get_omega() * dt + vector;
    quat.normalize();

    // integrate derivative terms to get updated current_state
    current_state.set_position( pos_rate * dt + current_state.get_position());      // update position
    current_state.set_velocity( vel_rate * dt + current_state.get_velocity());      // update velocity
    current_state.set_acceleration(acc);                                            // update acceleration

    current_state.set_omega( omega_rate * dt + current_state.get_omega());          // update angular velocity
    current_state.set_quaternion(quat);                                             // update angular velocity

    Eigen::Matrix3d R = quat.toRotationMatrix();
    current_state.set_R(R);                                // update rotation matrix
    current_state.set_euler(get_euler_from_R(R));          // update euler angle

    // constrain drone's state when it is on the ground
    grounding(current_state, acc);

    // update updated_state member
    updated_state = current_state;

    //std::cout<< "omega: " <<current_state.get_omega()(0)<<" "<<current_state.get_omega()(1)<<" "<<current_state.get_omega()(2)<<std::endl;
    //std::cout<< "omega rate: " <<omega_rate(0)<<" "<<omega_rate(1)<<" "<<omega_rate(2)<<std::endl;
    //std::cout<< "euler: "<<current_state.get_euler()(0)<<" "<<current_state.get_euler()(1)<<" "<<current_state.get_euler()(2)<<std::endl;

    return current_state;
}

// this version is implemented base on the source:
// http://andrew.gibiansky.com/downloads/pdf/Quadcopter%20Dynamics,%20Simulation,%20and%20Control.pdf
const State& QuadrotorDynamics::update_state4(State& current_state, const Eigen::Vector4d& motor_rpm, const std::vector<ptr_func >& external_force){

    // update rate of change of position and velocity of COM in world frame
    const Eigen::Vector3d& pos_rate = current_state.get_velocity();
    const Eigen::Vector3d& vel_rate = current_state.get_acceleration();

    // compute acceleration of COM in world frame
    determine_force(motor_rpm);                                                         // compute motor thrust forces in body frame
    Eigen::Vector3d acc = Eigen::Vector3d::Zero();
    for(auto iter = external_force.begin(); iter != external_force.end(); ++iter){      // add external forces(world frame)
        acc += (*iter)(current_state);
    }
    acc += current_force.sum() * current_state.get_R().col(2);                          // add thrust forces in world frame
    acc /= param.m;                                                                     // convert force to acceleration
    acc(2) -= param.g;                                                                  // add in gravity

    // update omega from euler rate
    Eigen::Matrix3d mapping = Eigen::Matrix3d::Identity();    // matrix that map euler rate to omega base on 3-2-1 convention
    mapping << 1.0,                                      0.0,                                           -std::sin(current_state.get_euler()(1)),
               0.0,   std::cos(current_state.get_euler()(0)),   std::sin(current_state.get_euler()(0)) * std::cos(current_state.get_euler()(1)),
               0.0,  -std::sin(current_state.get_euler()(0)),   std::cos(current_state.get_euler()(0)) * std::cos(current_state.get_euler()(1));

    current_state.set_omega(mapping * current_state.get_euler_rate());


    // compute rate of change of angular velocity
    determine_torque(motor_rpm);    // compute torque about COM in body frame
    Eigen::Vector3d omega_rate = param.inertia_inv * ( current_torque - current_state.get_omega().cross(param.inertia * current_state.get_omega()) ); // compute rate of change of angular velocity

    // update omega
    current_state.set_omega( omega_rate * dt + current_state.get_omega());          // update angular velocity

    // compute rate of change of euler angles
    Eigen::Matrix3d mapping2 = Eigen::Matrix3d::Identity();    // matrix that map angular velocity to euler angle base on 3-2-1 convention
    mapping2 << 1.0,   std::sin(current_state.get_euler()(0)) * std::tan(current_state.get_euler()(1)),   std::cos(current_state.get_euler()(0)) * std::tan(current_state.get_euler()(1)),
                0.0,                                            std::cos(current_state.get_euler()(0)),                                           -std::sin(current_state.get_euler()(0)),
                0.0,   std::sin(current_state.get_euler()(0)) / std::cos(current_state.get_euler()(1)),   std::cos(current_state.get_euler()(0)) / std::cos(current_state.get_euler()(1));

    Eigen::Vector3d euler_rate = mapping2 * current_state.get_omega();


    // integrate derivative terms to get updated current_state
    current_state.set_position( pos_rate * dt + current_state.get_position());      // update position
    current_state.set_velocity( vel_rate * dt + current_state.get_velocity());      // update velocity
    current_state.set_acceleration(acc);                                            // update acceleration
    current_state.set_euler( euler_rate * dt + current_state.get_euler());          // update euler angle
    current_state.set_euler_rate(euler_rate);                                       // update euler angle rate
    current_state.set_R( current_state.get_R_from_euler() );                        // update rotation matrix

    // constrain drone's state when it is on the ground
    grounding(current_state, acc);

    // update updated_state member
    updated_state = current_state;

    //std::cout<<current_state.get_omega()(0)<<" "<<current_state.get_omega()(1)<<" "<<current_state.get_omega()(2)<<std::endl;
    //std::cout<<omega_rate(0)<<" "<<omega_rate(1)<<" "<<omega_rate(2)<<std::endl;
    //std::cout<< "euler: "<<current_state.get_euler()(0)<<" "<<current_state.get_euler()(1)<<" "<<current_state.get_euler()(2)<<std::endl;

    return current_state;
}

// constrains the drone's state when it is on the ground
void QuadrotorDynamics::grounding(State& current_state, const Eigen::Vector3d& acc){

    // constrain z position, velocity and orientation when drone is on the ground
    if(current_state.get_position()(2) < 0.0){
        current_state.set_position(2, 0.0);
        current_state.set_velocity(Eigen::Vector3d::Zero());
        current_state.set_euler(0,0.0).set_euler(1,0.0);
        current_state.set_R(get_R_from_euler(current_state.get_euler()));
        current_state.set_quaternion(Eigen::Quaterniond(current_state.get_R()));
    }

    // constrain acceleration and omega when drone is on the ground
    if(current_state.get_position()(2) == 0.0 && acc(2) < 0.0){
        current_state.set_acceleration(Eigen::Vector3d::Zero());
        current_state.set_omega(Eigen::Vector3d::Zero());
        current_state.set_euler_rate(Eigen::Vector3d::Zero());
    }
}
